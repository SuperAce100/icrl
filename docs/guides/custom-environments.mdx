---
title: "Custom Environments"
description: "Build environments for your ICICL agents to interact with"
---

## Overview

Environments define the world your agent interacts with. They receive actions from the agent and return observations, determining when tasks succeed or fail.

## The Environment protocol

Every environment must implement the `Environment` protocol:

```python protocol.py
from icicl import Environment

class MyEnvironment:
    def reset(self, goal: str) -> str:
        """Reset the environment for a new episode.
        
        Args:
            goal: The goal description for this episode.
        
        Returns:
            Initial observation as a string.
        """
        ...

    def step(self, action: str) -> tuple[str, bool, bool]:
        """Execute an action in the environment.
        
        Args:
            action: The action string from the agent.
        
        Returns:
            Tuple of (observation, done, success):
            - observation: What the agent sees after the action
            - done: Whether the episode has ended
            - success: Whether the goal was achieved
        """
        ...
```

## Basic example

Here's a simple counter environment:

```python counter_env.py
class CounterEnvironment:
    def __init__(self, target: int = 10):
        self.target = target
        self.count = 0
        self._goal = ""
    
    def reset(self, goal: str) -> str:
        self._goal = goal
        self.count = 0
        return f"Counter initialized at 0. Target: {self.target}"
    
    def step(self, action: str) -> tuple[str, bool, bool]:
        action = action.strip().lower()
        
        if action == "increment":
            self.count += 1
            obs = f"Counter is now {self.count}"
        elif action == "decrement":
            self.count -= 1
            obs = f"Counter is now {self.count}"
        elif action.startswith("set "):
            try:
                self.count = int(action.split()[1])
                obs = f"Counter set to {self.count}"
            except (IndexError, ValueError):
                obs = "Error: Invalid set command. Use 'set N'"
        else:
            obs = f"Unknown action: {action}. Use: increment, decrement, set N"
        
        success = self.count == self.target
        done = success
        
        return obs, done, success
```

## File system environment

A more complex example that simulates a file system:

```python file_env.py
from pathlib import PurePosixPath

class FileSystemEnvironment:
    def __init__(self):
        self.cwd = "/"
        self.files = {
            "/home/user/notes.txt": "My notes",
            "/etc/config.json": '{"port": 8080}',
        }
        self.directories = {"/", "/home", "/home/user", "/etc"}
        self._goal = ""
    
    def reset(self, goal: str) -> str:
        self._goal = goal
        self.cwd = "/"
        return f"Current directory: /\nGoal: {goal}"
    
    def step(self, action: str) -> tuple[str, bool, bool]:
        parts = action.strip().split(maxsplit=1)
        cmd = parts[0].lower() if parts else ""
        args = parts[1] if len(parts) > 1 else ""
        
        if cmd == "ls":
            obs = self._ls(args or self.cwd)
        elif cmd == "cd":
            obs = self._cd(args)
        elif cmd == "cat":
            obs = self._cat(args)
        elif cmd == "pwd":
            obs = self.cwd
        else:
            obs = f"Unknown command: {cmd}"
        
        # Check success based on goal
        success = self._check_success()
        done = success
        
        return obs, done, success
    
    def _check_success(self) -> bool:
        # Implement goal-specific success checking
        goal = self._goal.lower()
        if "port" in goal:
            return "8080" in getattr(self, '_last_output', '')
        return False
    
    # ... additional helper methods
```

<Note>
See `examples/file_api_env.py` in the repository for the complete implementation.
</Note>

## Task-based environments

Create environments with verifiable tasks:

```python task_env.py
from dataclasses import dataclass
from typing import Callable

@dataclass
class Task:
    goal: str
    verify: Callable[['EnvState'], bool]
    setup: Callable[['EnvState'], None] | None = None

class TaskEnvironment:
    def __init__(self, task: Task):
        self.task = task
        self.state = {}
    
    def reset(self, goal: str) -> str:
        self.state = {"output": "", "actions": []}
        
        if self.task.setup:
            self.task.setup(self.state)
        
        return f"Ready. Goal: {self.task.goal}"
    
    def step(self, action: str) -> tuple[str, bool, bool]:
        self.state["actions"].append(action)
        obs = self._execute(action)
        self.state["output"] = obs
        
        success = self.task.verify(self.state)
        return obs, success, success

# Define tasks with verification
tasks = [
    Task(
        goal="Set counter to 42",
        verify=lambda s: s.get("counter") == 42,
    ),
    Task(
        goal="Create a file called test.txt",
        verify=lambda s: "test.txt" in s.get("files", []),
    ),
]
```

## API environment

Connect to real APIs or services:

```python api_env.py
import httpx

class APIEnvironment:
    def __init__(self, base_url: str):
        self.base_url = base_url
        self.client = httpx.Client()
        self._goal = ""
    
    def reset(self, goal: str) -> str:
        self._goal = goal
        return f"API at {self.base_url} ready. Goal: {goal}"
    
    def step(self, action: str) -> tuple[str, bool, bool]:
        try:
            parts = action.strip().split(maxsplit=2)
            method = parts[0].upper()
            path = parts[1] if len(parts) > 1 else "/"
            body = parts[2] if len(parts) > 2 else None
            
            url = f"{self.base_url}{path}"
            
            if method == "GET":
                response = self.client.get(url)
            elif method == "POST":
                response = self.client.post(url, json=eval(body) if body else {})
            else:
                return f"Unknown method: {method}", False, False
            
            obs = f"Status: {response.status_code}\n{response.text[:500]}"
            success = self._check_success()
            return obs, success, success
            
        except Exception as e:
            return f"Error: {str(e)}", False, False
```

<Warning>
When connecting to external APIs, implement proper error handling and rate limiting to avoid overwhelming the service.
</Warning>

## Best practices

<Steps>
  <Step title="Store the goal">
    Always store the goal in `reset()` for use in success checking:
    
    ```python
    def reset(self, goal: str) -> str:
        self._goal = goal  # Store for later
        return "Ready"
    ```
  </Step>
  
  <Step title="Return clear observations">
    Make observations informative but concise:
    
    ```python
    def step(self, action: str) -> tuple[str, bool, bool]:
        if action == "ls":
            # Good: Clear, structured output
            return "Files:\n- config.json\n- data.csv", False, False
        
        if error:
            # Good: Descriptive error
            return f"Error: File '{path}' not found. Check the path.", False, False
    ```
  </Step>
  
  <Step title="Handle invalid actions gracefully">
    ```python
    def step(self, action: str) -> tuple[str, bool, bool]:
        action = action.strip()
        
        if not action:
            return "Error: Empty action. Please provide a command.", False, False
        
        cmd = action.split()[0].lower()
        if cmd not in self.valid_commands:
            return (
                f"Unknown command: {cmd}\n"
                f"Valid commands: {', '.join(self.valid_commands)}",
                False,
                False
            )
    ```
  </Step>
  
  <Step title="Limit episode length">
    Prevent infinite loops:
    
    ```python
    def __init__(self, max_steps: int = 50):
        self.max_steps = max_steps
        self.step_count = 0

    def step(self, action: str) -> tuple[str, bool, bool]:
        self.step_count += 1
        
        if self.step_count >= self.max_steps:
            return "Maximum steps reached.", True, False
        
        # ... normal processing
    ```
  </Step>
</Steps>

## Testing environments

Test your environment before using it with an agent:

```python test_env.py
def test_environment():
    env = FileSystemEnvironment()
    
    # Test reset
    obs = env.reset("Find the config file")
    assert "Current directory" in obs
    
    # Test valid actions
    obs, done, success = env.step("ls")
    assert not done
    assert "home" in obs or "etc" in obs
    
    # Test navigation
    obs, done, success = env.step("cd /etc")
    assert "Changed" in obs
    
    # Test file reading
    obs, done, success = env.step("cat config.json")
    assert "8080" in obs
    
    # Test invalid action
    obs, done, success = env.step("invalid_command")
    assert "Unknown" in obs or "Error" in obs
    
    print("All tests passed!")

test_environment()
```

<Check>
Always test your environment independently before integrating with an agent. This makes debugging much easier.
</Check>

## Using with an agent

```python agent_integration.py
from icicl import Agent, LiteLLMProvider

# Create your environment
env = FileSystemEnvironment()

# Create agent with matching prompts
agent = Agent(
    llm=LiteLLMProvider(model="gpt-4o-mini"),
    db_path="./trajectories",
    plan_prompt="...",  # Mention available commands
    reason_prompt="...",
    act_prompt="...",
)

# Train
trajectory = await agent.train(env, goal="Find the config file")
print(f"Success: {trajectory.success}")
```

## Next steps

<CardGroup cols={2}>
  <Card title="Custom LLM Providers" icon="microchip" href="/guides/custom-llm-providers">
    Integrate custom LLM backends
  </Card>
  <Card title="File System Example" icon="folder" href="/examples/file-system-agent">
    See a complete environment implementation
  </Card>
</CardGroup>
